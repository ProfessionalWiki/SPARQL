!! options
parsoid-compatible
version=2
!! end


!! article
Module:MySPARQL
!! text
local sparql = require('SPARQL')
-- Import necessary modules
local mwHtml = require('mw.html')

-- Module definition
local p = {}

function reverseTable(t)
    local i, j = 1, #t

    while i < j do
        t[i], t[j] = t[j], t[i]
        i = i + 1
        j = j - 1
    end

    return t
end

-- Function to run SPARQL query and get results
local function runSparqlQuery(sparqlQuery)
    -- Assuming sparql.runQuery is available in your environment
    return sparql.runQuery(sparqlQuery)
end

-- Function to process SPARQL results into a Lua table
local function processResults(jsonResults)
    local resultsTable = {}
    if jsonResults and jsonResults.results and jsonResults.results.bindings then
        local bindings = jsonResults.results.bindings
        for _, binding in pairs(jsonResults.results.bindings) do
            local row = {}
            for key, value in pairs(binding) do
                table.insert(row, value.value)
            end
            row = reverseTable(row)
            table.insert(resultsTable, row)
        end
    end
    return reverseTable(resultsTable)
end

-- Function to create an HTML table from a Lua table
local function createHtmlTable(luaTable, headers)
    local htmlTable = mwHtml.create('table')
    htmlTable
        :addClass('wikitable')
        :attr('border', '1')
    
    if #headers > 1 then
        local headerRow = htmlTable:tag('tr')
        for j = 0, #headers do
            headerRow:tag('th'):wikitext(headers[j])
        end
    end

    for i = 1, #luaTable do
        local dataRow = htmlTable:tag('tr')
        for _, data in ipairs(luaTable[i]) do
            dataRow:tag('td'):wikitext(data)
        end
    end

    return tostring(htmlTable)
end

-- Main function to be called from a wiki page
function p.buildTableFromSparql(frame)
    local sparqlQuery = frame.args[1]
    local jsonResults = runSparqlQuery(sparqlQuery)
    local headers = {}
    if (jsonResults and jsonResults.head and jsonResults.head.vars) then
        headers = jsonResults.head.vars
    end    
    local resultsTable = processResults(jsonResults)
    return createHtmlTable(resultsTable, headers)
end

return p

!! endarticle


!! test
getLabel returns empty on subject not found
!! config
!! wikitext
{{#invoke:MySPARQL|buildTableFromSparql|
PREFIX wdt: <https://portal.mardi4nfdi.de/prop/direct/>
PREFIX wd: <https://portal.mardi4nfdi.de/entity/>

SELECT
  ?work
  ?title
  ?publication_date
WHERE {
  ?work wdt:P16 wd:Q195254 .
  ?work wdt:P159 ?title .
  OPTIONAL {
    ?work wdt:P28 ?publication_datetime .
    BIND(xsd:date(?publication_datetime) AS ?publication_date)
  }
}
ORDER BY DESC(?publication_date)
}}

!! html
<table class="wikitable" border="1"><tbody><tr><th>work</th><th>title</th><th>publication_date</th></tr><tr><td>2021-04-23</td><td>Regularity lemmas for clustering graphs</td><td><a rel="nofollow" class="external free" href="https://portal.mardi4nfdi.de/entity/Q2020028">https://portal.mardi4nfdi.de/entity/Q2020028</a></td></tr><tr><td>2017-09-20</td><td>Juggling card sequences</td><td><a rel="nofollow" class="external free" href="https://portal.mardi4nfdi.de/entity/Q2404825">https://portal.mardi4nfdi.de/entity/Q2404825</a></td></tr><tr><td>2020-01-31</td><td>Slow Fibonacci walks</td><td><a rel="nofollow" class="external free" href="https://portal.mardi4nfdi.de/entity/Q2291703">https://portal.mardi4nfdi.de/entity/Q2291703</a></td></tr></tbody></table>
!! end
